for i,Bots in pairs(getBots()) do 
    if Bots.name:upper() == getBot().name:upper() then 
        indexBot = i 
    end
    indexLast = i
end

bot = getBot() 
bot.move_interval = botMoveInterval
bot.move_range = botMoveRange
bot.legit_mode = botAnimation
nuked = false
t = os.time()
rb = os.time()
worldFarm = ""
doorFarm = ""
worldBreak = ""
doorBreak = ""
worldPNBTutor = ""
worldListBot = {}
totalFarm = 0
totalPack = 0 
totalSeed = 0
mode3Tile = {-2,-1,0,1,2}
tree = {} 
waktu = {} 
fossil = {}
currentClothes = {}
emoteChat = {"/troll","/love"}
tileBreak = {} 
devideSeed = math.ceil(indexLast / #storageSeed)
storageSeed = storageSeed[math.ceil(indexBot/devideSeed)]
devidePack = math.ceil(indexLast / #storagePack)
storagePack = storagePack[math.ceil(indexBot / devidePack)]
minimumGems = pricePack * minBuyPack
local year = 2023
local month = 12 
local dates = 14
function getFresh(y,m,d)
    local currentTime = t 
    local targetTime = os.time({year = y,month = m,day = d})
    local timeDiff = currentTime - targetTime
    local dayDiff = timeDiff / (24 * 60 * 60)
    dayDiff = math.floor(dayDiff)
    return dayDiff
end
dayFreshBot = getFresh(year,month,dates)
if bot:getAge() >= dayFreshBot then 
    freshBot = false
else 
    freshBot = true
end 

for i = math.floor(breakTile/2),1,-1 do
        i = i * -1
    table.insert(tileBreak,i)
end
for i = 0, math.ceil(breakTile/2) - 1 do
    table.insert(tileBreak,i)
end

function punch(x,y)
    return bot:hit(bot.x + x,bot.y + y)
end

function place(id,x,y)
    return bot:place(bot.x + x, bot.y + y,id)
end

function tileDrop(x,y,num)
    local count = 0
    local stack = 0
    for _,obj in pairs(bot:getWorld():getObjects()) do
        if round(obj.x / 32) == x and math.floor(obj.y / 32) == y then
            count = count + obj.count
            stack = stack + 1
        end
    end
    if stack < 20 and count <= (4000 - num) then
        return true
    end
    return false
end
function numF(n)
  return tostring(math.floor(n)):reverse():gsub("(%d%d%d)","%1."):gsub(",(%-?)$","%1"):reverse()
end

function placeItem(id,x,y)
    while bot:getWorld():getTile(bot.x + x,bot.y + y).fg ~= id and bot:getWorld():hasAccess(x,y) > 0 do 
        place(id,x,y)
        sleep(200)
    end
end

function tilePlace(x,y)
   for _,num in pairs(tileBreak) do
      if bot:getWorld():getTile(x - 1,y + num).fg == 0 and bot:getWorld():getTile(x - 1,y + num).bg == 0 and bot:getWorld():hasAccess(x -1,y + num) > 0 then
          return true
      end
  end
  return false
end
function tilePunch(x,y)
   for _,num in pairs(tileBreak) do
      if bot:getWorld():getTile(x - 1,y + num).fg ~= 0 or bot:getWorld():getTile(x - 1,y + num).bg ~= 0 and bot:getWorld():hasAccess(x -1,y + num) > 0 then
         return true
      end
   end
   return false
end

function includesNumber(table, num)
    for _,n in pairs(table) do
        if n == num then
            return true
        end
    end
    return false
end


function takefile(fileTxt)
    local file = io.open(fileTxt, "r")
    local result = {}
    local lines = {}
    if file then 
        for line in file:lines() do
            table.insert(lines, line)
            local data = split(line, ":")
            if tablelength(data) == 2 then
                table.insert(result, {
                    world = data[1],
                    door = data[2],
                })
            end
        end
        file:close()
        lines1 = lines[1]
        table.remove(lines,1)
        file = io.open(fileTxt,"w")
        if file then 
            for _,line in ipairs(lines) do 
                file:write(line.."\n")
            end
            file:write(lines1)
            file:close()
        end
    end
    return result
end

function split(inputstr, sep)
    if sep == nil then
        sep = "%s"
    end
    local t = {}
    for str in string.gmatch(inputstr, "([^" .. sep .. "]+)") do
        table.insert(t, str)
    end
    return t
end

function getStatus(inibot)
    local status = {
        [BotStatus['offline']] = 'Offline',
        [BotStatus["online"]] = "Online",
        [BotStatus["account_banned"]] = "Banned",
        [BotStatus["location_banned"]] = "Location Banned",
        [BotStatus["server_overload"]] = "Overload",
        [BotStatus["too_many_login"]] = "Too Many Login",
        [BotStatus["maintenance"]] = "Maintenance",
        [BotStatus["version_update"]] = "Version Update",
        [BotStatus["server_busy"]] = "Server Busy",
        [BotStatus["error_connecting"]] = "Error Connecting",
        [BotStatus["logon_fail"]] = "Login Fail",
        [BotStatus["high_load"]] = "High Load",
        [BotStatus["changing_subserver"]] = "Changing Subserver",
        [BotStatus["account_restricted"]] = "Acc Restricted",
        [BotStatus["network_restricted"]] = "Network Restricted",
        [BotStatus["getting_server_data"]] =  "Getting Server",
        [BotStatus["bypassing_server_data"]] =  "Bypass",
        [BotStatus["http_block"]] =  "Http Block",
        [BotStatus["high_ping"]] =  "High Ping"
    }
    return status[inibot.status]
end

function tablelength(T)
    local count = 0
    for _ in pairs(T) do 
        count = count + 1 
    end
    return count
end

function round(n)
    return n % 1 > 0.5 and math.ceil(n) or math.floor(n)
end

function warp(world,id)
    addEvent(Event.variantlist, function(variant, netid)
        if variant:get(0):getString() == "OnConsoleMessage" then
            if variant:get(1):getString():find("inaccessible") then
                nuked = true
            end
        end
    end)
    suck = 0
    wrongDoor = 0 
    while bot:getWorld().name:upper() ~= world:upper() and not nuked do 
        while bot.status ~= BotStatus.online do 
            sleep(1000)
        end
        if bot:isInWorld() then 
            if id ~= "" then 
                bot:sendPacket(3,"action|join_request\nname|"..world:upper().."|"..id:upper().."\ninvitedWorld|0")
                listenEvents(2)
            else 
                bot:sendPacket(3,"action|join_request\nname|"..world:upper().."\ninvitedWorld|0")
                listenEvents(2)
            end
        else 
            if id ~= "" then 
                bot:sendPacket(3,"action|quit_to_exit")
                sleep(1000)
                bot:sendPacket(3,"action|join_request\nname|"..world:upper().."|"..id:upper().."\ninvitedWorld|0")
                listenEvents(2)
            else
                bot:sendPacket(3,"action|quit_to_exit")
                sleep(1000)
                bot:sendPacket(3,"action|join_request\nname|"..world:upper().."\ninvitedWorld|0")
                listenEvents(2)
            end
        end
        sleep(delayWarp - 2000)
        if suck == 5 then
            notifBot(webhookOffline,"<a:ping:1233214776880922757> "..getBot().name.." ("..indexBot..") Cannot Join World ||"..world:upper().."|| Waiting "..delayHardWarp.." Minutes")
            sleep(delayHardWarp * 60 * 1000)
        else
            suck = suck + 1
        end
    end
    if id ~= "" and bot:getWorld():getTile(bot.x,bot.y).fg == 6 and not nuked then 
        while bot:getWorld():getTile(bot.x,bot.y).fg == 6 and not nuked do 
            bot:sendPacket(3,"action|quit_to_exit")
            sleep(1000)
            bot:sendPacket(3,"action|join_request\nname|"..world:upper().."|"..id:upper().."\ninvitedWorld|0")
            listenEvents(2)
            if wrongDoor == 3 then 
                notifBot(webhookOffline,"<a:ping:1233214776880922757> "..getBot().name.." ("..indexBot..") Cannot Join Door ||"..world:upper().."||")
                nuked = true
            else 
                wrongDoor = wrongDoor + 1
            end
            sleep(5000)
        end
    end
    removeEvent()
end

function reconnect(world,id,x,y)
     if restBotMode ~= "" then
        restingBot(world,id,x,y)
    end
    if bot.status == BotStatus.online and (bot.x ~= x or bot.y ~= y) then
        notifBot(webhookOffline,bot.name:upper().."("..indexBot..") Bot Stuck Current X:"..x.."Current Y:"..y)
        while bot:getWorld().name ~= world:upper() do
            if bot:isInWorld() then 
                bot:sendPacket(3,"action|quit_to_exit")
                sleep(500)
                bot:sendPacket(3,"action|join_request\nname|"..world:upper().."\ninvitedWorld|0")
                sleep(10000)
            else
                bot:sendPacket(3,"action|join_request\nname|"..world:upper().."\ninvitedWorld|0")
                sleep(10000)
            end
        end
        if id ~= "" and bot:getWorld():getTile(bot.x,bot.y).fg == 6 then
            bot:sendPacket(3,"action|quit_to_exit")
            sleep(1000)
            bot:sendPacket(3,"action|join_request\nname|"..world:upper().."|"..id:upper().."\ninvitedWorld|0")
            sleep(2000)
        end
        if x and y and (bot.x ~= x or bot.y ~= y) then
            bot:findPath(x,y)
            sleep(100)
        end
    end
    if bot.status ~= BotStatus.online or bot:getPing() == 0 then
        notifBot(webhookOffline,"<a:ping:1233214776880922757> "..getBot().name.." ("..indexBot..") Bot Status is "..getStatus(bot))
        sleep(100)
        while bot.status ~= BotStatus.online or bot:getPing() == 0 do
            sleep(1000)
        end
        while bot:getWorld().name ~= world:upper() do
            if bot:isInWorld() then 
                bot:sendPacket(3,"action|quit_to_exit")
                sleep(500)
                bot:sendPacket(3,"action|join_request\nname|"..world:upper().."\ninvitedWorld|0")
                sleep(10000)
            else
                bot:sendPacket(3,"action|join_request\nname|"..world:upper().."\ninvitedWorld|0")
                sleep(10000)
            end
        end
        if id ~= "" and bot:getWorld():getTile(bot.x,bot.y).fg == 6 then
            bot:sendPacket(3,"action|quit_to_exit")
            sleep(1000)
            bot:sendPacket(3,"action|join_request\nname|"..world:upper().."|"..id:upper().."\ninvitedWorld|0")
            sleep(2000)
        end
        if x and y and (bot.x ~= x or bot.y ~= y) then
            bot:findPath(x,y)
            sleep(100)
        end
    end
end

function restingBot(world,door,x,y)
    currentTime = os.time()
    if restBotMode == "HOUR" then 
        for _,rest in pairs(HourTime) do  
            if os.date("%H:%M", os.time() + rangeTimeRdp * 60 * 60) == rest then
                if disconnectOnRest then 
                    bot.auto_reconnect = false 
                    sleep(100)
                    bot:disconnect()
                end
                notifBot(webhookOffline,"<a:questionsyn:1235453801758982216> "..getBot().name.." ("..indexBot..") Resting Time")
                sleep(restDuration * 60 * 1000)
                bot.auto_reconnect = true
                reconnect(world,door,x,y)
            end
        end 
    elseif restBotMode == "INTERVAL" then 
        restNow = currentTime - rb
        if restNow >= (intervalTime * 60) then 
            if disconnectOnRest then 
                bot.auto_reconnect = false 
                sleep(100)
                bot:disconnect()
            end
            notifBot(webhookOffline,"<a:questionsyn:1235453801758982216> "..getBot().name.." ("..indexBot..") Resting Time")
            sleep(restDuration * 60 * 1000)
            rb = os.time()
            bot.auto_reconnect = true
            reconnect(world,door,x,y)
        end
    end
end


function takeItem(world,door,id,amount)
    bot.auto_collect = false 
    sleep(100)
    warp(world,door)
    sleep(100)
    if not nuked then 
        for _, obj in pairs(bot:getWorld():getObjects()) do 
            if obj.id == id then 
                bot:findPath(round(obj.x/32),math.floor(obj.y/32))
                bot:collectObject(obj.oid,3)
                sleep(500)
            end
            if bot:getInventory():findItem(id) > amount then 
                break
            end
        end
        bot:moveTo(-1,0)
        sleep(500)
        bot:setDirection(false)
        sleep(100)
        if bot:getInventory():findItem(id) > amount then 
            while bot:getInventory():findItem(id) > amount do 
                bot:sendPacket(2,"action|drop\n|itemID|"..id)
                sleep(500)
                bot:sendPacket(2,"action|dialog_return\ndialog_name|drop_item\nitemID|"..id.."|\ncount|"..bot:getInventory():findItem(id) - amount)
                sleep(3000)
                bot:moveTo(1,0)
            end
        end
    else 
        notifBot(webhookNuked,"<a:ping:1233214776880922757> ||".. worldFarm:upper().. "|| NUKED @everyone !  ")
        print(world:upper().." NUKED")
        nuked = false
    end
end

function clearFire(world,door) 
    while bot:getInventory():findItem(3066) == 0 do
        takeItem(worldFireHose,doorFireHose,3066,1)
    end
    warp(worldFarm,doorFarm)
    sleep(100)
    if not nuked then 
        for _,tile in pairs(bot:getWorld():getTiles()) do 
            if tile:hasFlag(4096) then 
                if bot:getWorld():getTile(tile.x,tile.y).fg == 0 or bot:getWorld():getTile(tile.x,tile.y).fg == itmSeed then 
                    bot:findPath(tile.x,tile.y)
                    sleep(100)
                    ex = bot.x
                    ye = bot.y
                    for xfire = -3,3,1 do 
                        for yfire = -3,3,1 do 
                            if bot:getWorld():getTile(ex + xfire,ye + yfire):hasFlag(4096) and bot:getWorld().name == worldFarm:upper() then 
                                while bot:getWorld():getTile(ex + xfire,ye + yfire):hasFlag(4096) do 
                                    punch(ex + xfire,ye + yfire)
                                    sleep(200)
                                    reconnect(worldFarm,doorFarm,ex,ye)
                                end
                            end
                        end
                    end
                end
            end
        end
    else 
        notifBot(webhookNuked,"<a:ping:1233214776880922757> ||".. worldFarm:upper().. "|| NUKED @everyone !  ")
        print(worldFarm:upper().."NUKED")
        nuked = false
    end
end

function reconnectHarvest(world,door)
    if bot.status ~= BotStatus.online or bot:getPing() == 0 then 
        notifBot(webhookOffline,"<a:ping:1233214776880922757> "..getBot().name.." ("..indexBot..") Bot Status "..getStatus(bot))
        sleep(100)
        while bot.status ~= BotStatus.online or bot:getPing() == 0 do 
            sleep(1000)
        end
        if takePickaxe and bot:getInventory():findItem(98) == 0 and bot.status == BotStatus.online then 
            takeItem(worldPick,doorPick,98,1)
        end
        while not bot:isInWorld(world:upper()) do 
            bot:sendPacket(3,"action|join_request\nname|"..world:upper().."\ninvitedWorld|0")
            sleep(delayWarp)
        end
        if id ~= "" and bot:getWorld():getTile(bot.x,bot.y).fg == 6 then 
            bot:sendPacket(3,"action|quit_to_exit")
            sleep(1000)
            bot:sendPacket(3,"action|join_request\nname|"..world:upper().."|"..door:upper().."\ninvitedWorld|0")
            sleep(5000)
        end
    end
end
  
function harvest(world)
    tiley = 0
    tree[world] = 0
    bot.auto_collect = true
    bot.collect_interval = 100
    if harvestIgnoreGems and farmRoot then
        bot.ignore_gems = true
    end
    if modeHarvest == "DOWN" then 
        start = 0
        ends = 53 
        step = 1
    else 
        start = 53
        ends = 0
        step = -1
    end
    harvest1 = 0 
    harvest2 = 99 
    harvest3 = 1 
    istile = 0 
    isme = 2
    if bot.level < getInfo(itmId).level and freshBot then
        for yHarvest = start,ends,step do 
            for xHarvest = harvest1,harvest2,harvest3 do 
              reconnectHarvest(world,doorFarm)
                if bot.status == BotStatus.online and bot:getWorld():getTile(xHarvest,yHarvest):canHarvest() and bot:getWorld():hasAccess(xHarvest,yHarvest) > 0 and bot.level < getInfo(itmId).level then
                    if bot:findPath(xHarvest,yHarvest) then
                        if takeWearEvent then
                           local cloth = bot:getWorld():getLocal().clothes
                            while bot:getInventory():findItem(idWear) == 0 do 
                                takeItem(storageWearEvent,doorWearEvent,idWear,minTake)
                            end
                            if bot:getInventory():findItem(idWear) > 0 and cloth.neck ~= idWear then 
                                bot:wear(idWear)
                                sleep(100)
                            end
                        end
                        for _, i in pairs(mode3Tile) do 
                            if bot:getWorld():getTile(xHarvest + i,yHarvest).fg == itmSeed and bot:getWorld():getTile(xHarvest + i,yHarvest):canHarvest() and bot:getWorld():hasAccess(xHarvest + i,yHarvest) > 0 then
                            tree[world] = tree[world] + 1
                                while bot:getWorld():getTile(xHarvest + i,yHarvest).fg == itmSeed and bot:getWorld():getTile(xHarvest + i,yHarvest):canHarvest() and bot:getWorld():hasAccess(xHarvest + i,yHarvest) > 0 and bot.x == xHarvest and bot.y == yHarvest do
                                    punch(i,0)
                                    sleep(delayHarvest)
                                    reconnect(world,doorFarm,xHarvest,yHarvest)
                                end
                            end
                        end
                        if farmRoot then
                            for _, i in pairs(mode3Tile) do
                                while bot:getWorld():getTile(xHarvest+ i, yHarvest + 1).fg == (itmId + 4) and bot.x == xHarvest and bot.y == yHarvest do
                                  punch(i, 1)
                                  sleep(delayHarvest)
                                  reconnect(world,doorFarm,xHarvest,yHarvest)
                                end
                            end
                        end
                    end
                end
                if bot.level >= getInfo(itmId).level then
                    break
                end
            end
            if istile == 1 then 
                if harvest1 == 0 then 
                    harvest1 = 99 
                    harvest2 = 0 
                    harvest3 = -1 
                    istile = 0 
                    isme = -2
                elseif harvest1 == 99 then 
                    harvest1 = 0 
                    harvest2 = 99 
                    harvest3 = 1
                    istile = 0 
                    isme = 2
                end
            else 
                istile = istile + 1
            end 
            if bot.level >= getInfo(itmId).level then
                break
            end
        end
    end
    if takeFloating and (bot.level >= getInfo(itmId).level or not freshBot) then
        scanReady()
        for _,obj in pairs(bot:getWorld():getObjects()) do
            if obj.id == itmId then
                bot:findPath(round(obj.x / 32),math.floor(obj.y / 32))
                sleep(100)
                bot:collect(3)
                sleep(100)
            end
            if bot:getInventory():findItem(itmId) >= 190 then
                pnb(world)
                sleep(100)
                if bot:getInventory():findItem(itmSeed) > 150 then
                    storeProfit(storageSeed,doorSeed,itmSeed)
                    sleep(100)
                end
            end
        end
    end
    if bot.level >= getInfo(itmId).level or not freshBot then
        if dontPlant then
            for yHarvest = start,ends,step do
                scanReady()
                for xHarvest = harvest1,harvest2,harvest3 do
                    reconnectHarvest(world,doorFarm)
                    if bot.status == BotStatus.online and  bot:getWorld():getTile(xHarvest,yHarvest):canHarvest() and bot:getWorld():hasAccess(xHarvest,yHarvest) > 0 and (bot.level >= getInfo(itmId).level or not freshBot) then
                        if bot:findPath(xHarvest,yHarvest) then
                            if takeWearEvent then
                               local cloth = bot:getWorld():getLocal().clothes

                                while bot:getInventory():findItem(idWear) == 0 do 
                                    takeItem(storageWearEvent,doorWearEvent,idWear,minTake)
                                end
                                if bot:getInventory():findItem(idWear) > 0 and cloth.neck ~= idWear then 
                                    bot:wear(idWear)
                                    sleep(100)
                                end
                            end
                            if tiley ~= yHarvest then
                                tiley = yHarvest
                                sleep(100)
                                botEvent("Currently in row "..math.ceil(tiley/2).."/27")
                            end
                            for _, i in pairs(mode3Tile) do
                                if bot:getWorld():getTile(xHarvest+ i,yHarvest).fg == itmSeed and bot:getWorld():getTile(xHarvest + i,yHarvest):canHarvest() and bot:getWorld():hasAccess(xHarvest + i,yHarvest) > 0 and bot:getWorld().name == world:upper() then
                                    tree[world] = tree[world] + 1
                                    while bot:getWorld():getTile(xHarvest + i,yHarvest).fg == itmSeed and bot:getWorld():getTile(xHarvest + i,yHarvest):canHarvest() and bot:getWorld():hasAccess(xHarvest + i, yHarvest) > 0 and bot.x == xHarvest and bot.y == yHarvest and bot:getWorld().name == world:upper() do 
                                        punch(i,0)
                                        sleep(delayHarvest)
                                        reconnect(world,doorFarm,xHarvest,yHarvest)
                                    end
                                end
                            end
                            if farmRoot then 
                                for _, i in pairs(mode3Tile) do
                                    while bot:getWorld():getTile(xHarvest + i, yHarvest + 1).fg == (itmId + 4) and xHarvest == xHarvest and bot.y == yHarvest do
                                        punch(i, 1)
                                        sleep(delayHarvest)
                                        reconnect(world,doorFarm,xHarvest,yHarvest)
                                    end
                                end
                            end
                        end
                    end
                    if bot:getInventory():findItem(itmId) >= 190 and (bot.level >= getInfo(itmId).level or not freshBot) then
                        pnb(world)
                        sleep(100)
                        if bot:getInventory():findItem(itmSeed) > 150 then
                            storeProfit(storeSeed,doorSeed,itmSeed)
                            sleep(100)
                        end
                    end
                end
                if istile == 1 then 
                    if harvest1 == 0 then 
                        harvest1 = 99 
                        harvest2 = 0 
                        harvest3 = -1 
                        istile = 0 
                        isme = -2
                    elseif harvest1 == 99 then 
                        harvest1 = 0 
                        harvest2 = 99 
                        harvest3 = 1
                        istile = 0 
                        isme = 2
                    end
               else 
                    istile = istile + 1
                end 
            end
        else 
            for yHarvest = start,ends,step do
                scanReady()
                for xHarvest = harvest1,harvest2,harvest3 do
                    reconnectHarvest(world,doorFarm)
                    if bot.status == BotStatus.online and getTile(xHarvest,yHarvest):canHarvest() and bot:getWorld():hasAccess(xHarvest,yHarvest) > 0 and (bot.level >= getInfo(itmId).level or not freshBot) then
                        if bot:findPath(xHarvest,yHarvest) then
                            if takeWearEvent then
                               local cloth = bot:getWorld():getLocal().clothes
                                while bot:getInventory():findItem(idWear) == 0 do 
                                    takeItem(storageWearEvent,doorWearEvent,idWear,minTake)
                            end
                                if bot:getInventory():findItem(idWear) > 0 and cloth.neck ~= idWear then 
                                    bot:wear(idWear)
                                    sleep(100)
                                end
                            end
                            for _, i in pairs(mode3Tile) do
                                if bot:getWorld():getTile(xHarvest+ i,yHarvest).fg == itmSeed and bot:getWorld():getTile(xHarvest + i,yHarvest):canHarvest() and bot:getWorld():hasAccess(xHarvest + i,yHarvest) > 0 and bot:getWorld().name == world:upper() then
                                    tree[world] = tree[world] + 1
                                    while bot:getWorld():getTile(xHarvest + i,yHarvest).fg == itmSeed and bot:getWorld():getTile(xHarvest + i,yHarvest):canHarvest() and bot:getWorld():hasAccess(xHarvest + i, yHarvest) > 0 and bot.x == xHarvest and bot.y == yHarvest and bot:getWorld().name == world:upper() do 
                                        punch(i,0)
                                        sleep(delayHarvest)
                                        reconnect(world,doorFarm,xHarvest,yHarvest)
                                    end
                                end
                            end
                            if farmRoot then 
                                for _, i in pairs(mode3Tile) do
                                    while bot:getWorld():getTile(xHarvest + i, yHarvest + 1).fg == (itmId + 4) and bot.x == xHarvest and bot.y == yHarvest do
                                        punch(i, 1)
                                        sleep(delayHarvest)
                                        reconnect(world,doorFarm,xHarvest,yHarvest)
                                    end
                                end
                            end
                            for _, i in pairs(mode3Tile) do
                                while bot:getWorld():getTile(xHarvest + i,yHarvest).fg == 0 and isPlantable(bot:getWorld():getTile(xHarvest + i,yHarvest + 1)) and bot:getInventory():findItem(itmSeed) > 0 and bot:getWorld():hasAccess(xHarvest + i,yHarvest) > 0 and bot.x == xHarvest and bot.y == yHarvest and bot:getWorld().name == world:upper() do 
                                    place(itmSeed,i,0)
                                    sleep(delayPlant)
                                    reconnect(world,doorFarm,xHarvest,yHarvest)
                                end
                            end
                        end
                    end
                    if bot:getInventory():findItem(itmId) >= 190 and (bot.level >= getInfo(itmId).level or not freshBot) then
                        pnb(world)
                        sleep(100)
                        if bot:getInventory():findItem(itmSeed) > 150 then
                            storeProfit(storeSeed,doorSeed,itmSeed)
                            sleep(100)
                        end
                    end
                end
                if istile == 1 then 
                    if harvest1 == 0 then 
                        harvest1 = 99 
                        harvest2 = 0 
                        harvest3 = -1 
                        istile = 0 
                        isme = -2
                    elseif harvest1 == 99 then 
                        harvest1 = 0 
                        harvest2 = 99 
                        harvest3 = 1
                        istile = 0 
                        isme = 2
                    end
               else 
                    istile = istile + 1
                end 
            end
        end
    end
    if refillFarm then 
        for _,tile in pairs(bot:getWorld():getTiles()) do
            if bot:getInventory():findItem(itmSeed) == 0 then
                take(world)
                sleep(100)
            end
            if (tile.fg == 0 and isPlantable(bot:getWorld():getTile(tile.x,tile.y + 1))) and bot:isInWorld(world:upper()) and bot:getWorld():hasAccess(tile.x,tile.y) > 0 then
                if bot:findPath(tile.x,tile.y) then
                    for _, i in pairs(mode3Tile) do
                        while bot:getWorld():getTile(tile.x + i,tile.y).fg == 0 and isPlantable(bot:getWorld():getTile(tile.x + i,tile.y + 1)) and bot:getWorld():hasAccess(tile.x + i,tile.y) > 0 and bot:getInventory():findItem(itmSeed) > 0 and bot.x == tile.x and bot.y == tile.y and bot:getWorld().name == world:upper() do
                            place(itmSeed,i,0)
                            sleep(delayPlant)
                            reconnect(world,doorFarm,tile.x,tile.y)
                        end
                    end
                end
            end
        end
    end 
end 

function isPlantable(tile)
    local tempTile = tile -- get tile below
    if not tempTile.fg then 
        return false 
    end
    local collision = getInfo(tempTile.fg).collision_type
    return tempTile and ( collision == 1 or collision == 2 )-- 1 = solid, 2 = withPlats
end

function take(world)
    bot.auto_collect = false 
    sleep(100)
    warp(storageSeed,doorSeed)
    sleep(100)
    if not nuked then 
        for _,obj in pairs(bot:getWorld():getObjects()) do 
            if obj.id == itmSeed then 
                bot:findPath(round(obj.x/32),math.floor(obj.y/32))
                bot:collectObject(obj.oid,3)
            end
            if bot:getInventory():findItem(itmSeed) > 0 then 
                break
            end
        end 
    else
        notifBot(webhookNuked,bot.name:upper().." ("..indexBot..") ||"..storageSeed:upper().."|| Nuked @everyone")
    end
    warp(world,doorFarm)
end
function pnbOtherWorld()
    PNBOtherData = takefile(listPNBDifferent)[1]
    if PNBOtherData then
        worldBreak = PNBOtherData.world
        doorBreak = PNBOtherData.door
    end
    sleep(100)
    warp(worldBreak,doorBreak)
    sleep(100)
    if not nuked and bot:isInWorld(worldBreak:upper()) then
        if bot:getInventory():findItem(itmId) >= breakTile and bot:getWorld().name == worldBreak:upper() then
            if not customTileBreak then 
                ex = bot.x
                ye = bot.y
            else 
                ex = posX
                ye = posY
            end
            bot.auto_collect = true
            while bot:getInventory():findItem(itmId) > breakTile and bot:getInventory():findItem(itmSeed) <= 190 and bot.x == ex and bot.y == ye and bot:getWorld().name == worldBreak:upper() do
                while tilePlace(ex,ye) do
                    for _,i in pairs(tileBreak) do
                        if bot:getWorld():getTile(ex - 1,ye + i).fg == 0 and bot:getWorld():getTile(ex - 1,ye + i).bg == 0 then
                            place(itmId,-1,i)
                            sleep(delayPlace)
                            reconnect(worldBreak,doorBreak,ex,ye)
                        end
                    end
                end
                while tilePunch(ex,ye) do
                    for _,i in pairs(tileBreak) do
                        if bot:getWorld():getTile(ex - 1,ye + i).fg ~= 0 or bot:getWorld():getTile(ex - 1,ye + i).bg ~= 0 then
                            punch(-1,i)
                            if variationDelay then
                                sleep(math.random(delayPunch - breakVariationDelay,delayPunch + breakVariationDelay))
                            else
                                sleep(delayPunch)
                            end
                            reconnect(worldBreak,doorBreak,ex,ye)
                        end
                    end
                end
            end
        end
    elseif nuked then
        removeWb(listPNBDifferent, worldBreak)
        sleep(100)
    end
end

function removeWb(fileName,world)
    local file = io.open(fileName,"r")
    if file then 
        local lines = {}
        for line in file:lines() do 
            table.insert(lines, line)
        end
        file:close()
        local pattern = world..":"..doorBreak
        for i, line in ipairs(lines) do 
            if line:match(pattern) then 
                table.remove(lines, i)
                break
            end
        end
        local file = io.open(fileName, "w")
        if file then 
            for _,line in ipairs(lines) do 
                file:write(line.."\n")
            end
            file:close()
        end
    end
    nuked = false
    if createWbIfNuked then 
        notifBot(webhookNuked,bot.name:upper().." ("..indexBot..") Creating New WorldBreak")
        bot.auto_collect = false 
        sleep(100)
        takeItem(storageWorldBreak,doorStorageWorldBreak,202,1)
        sleep(100)
        takeItem(storageWorldBreak,doorStorageWorldBreak,2,1)
        sleep(100)
        takeItem(storageWorldBreak,doorStorageWorldBreak,enteranceId,2)
        sleep(200)
        takeItem(storageWorldBreak,doorStorageWorldBreak,idDoor,2)
        if withJammer then 
            takeItem(storageWorldBreak,doorStorageWorldBreak,226,1)
            sleep(100)
        end
        repeat 
            nuked = false
            worldz = name(letterWorld)
            sleep(100)
            warp(worldz,"")
        until checkLock() and countTile() and not nuked
        ex = bot.x 
        ye = bot.y
        reconnect(worldz,"",ex,ye)
        placeItem(202,0,-1)
        reconnect(worldz,"",ex,ye)
        if withJammer then 
            placeItem(226,1,-1)
            reconnect(worldz,"",ex,ye)
            punch(1,-1)
            sleep(300)
        end
        placeItem(enteranceId,1,0)
        reconnect(worldz,"",ex,ye)
        placeItem(enteranceId,-1,0)
        reconnect(worldz,"",ex,ye)
        placeItem(idDoor,-1,-1)
        reconnect(worldz,"",ex,ye)
        reapply(0,-1)
        while bot:getWorld():getTile(bot.x,bot.y).fg == 6 do 
            reconnect(worldz,"",ex,ye)
            edit(-1,-1,doorId)
            sleep(100)
            bot:warp(worldz,doorId)
            sleep(5000)
        end
        local file = io.open(listPNBDifferent, "a")
        if file then 
            file:write(worldz..":"..doorId.."\n")
        end
        file:close()
    end
    notifBot(webhookNuked,bot.name:upper().." ("..indexBot..") ||"..worldz:upper().."|| New WorldBreak")
    pnb(worldFarm)
end

function reapply(x,y)
    bot:wrench(getBot().x + x,getBot().y + y)
    sleep(1000)
    bot:sendPacket(2,"action|dialog_return\ndialog_name|lock_edit\ntilex|"..(getBot().x + x).."|\ntiley|"..(getBot().y + y).."|\nbuttonClicked|recalcLock\n\ncheckbox_public|0\ncheckbox_ignore|1")
    sleep(1000)
end

function edit(x,y,id)
    bot:wrench(getBot().x + x,getBot().y + y)
    sleep(1000)
    bot:sendPacket(2,"action|dialog_return\ndialog_name|door_edit\ntilex|"..(getBot().x + x).."|\ntiley|"..(getBot().y + y).."|\ndoor_name|\ndoor_target|\ndoor_id|"..id.."\ncheckbox_locked|1")
    sleep(1000)
end

function checkLock()
    locks = {242,9640,202,204,206,1796,4994,7188,408,2950,4428,4802,5814,5260,5980,8470,10410,11550,11586}
    for _,tile in pairs(bot:getWorld():getTiles()) do
        if includesNumber(locks, tile.fg) then
            return false
        end
    end
    return true
end

function countTile()
    countFg = 0
    countBg = 0
    for _,tile in pairs(bot:getWorld():getTiles()) do
        if tile.fg ~= 0 then
            countFg = countFg + 1
        end
        if tile.bg ~= 0 then
            countBg = countBg + 1
        end
    end
    if countBg == 3600 and countFg == 3601 then
        return true
    end
    return false
end

function name(count)
    if withNumber then
        local str = ""
        local chars = "abcdefghijklmnopqrstuvwxyz0123456789"
        for i = 1, count do
            local randomIndex = math.random(1, #chars)
            str = str .. chars:sub(randomIndex, randomIndex)
        end
        return str:upper()
    else
        local str = ""
        for i = 1, count do
            str = str..string.char(math.random(97,122))
        end
        return str:upper()
    end
end

function createNewWb()
    if bot:getInventory():findItem(9640) > 0 then 
        repeat 
            nuked = false
            worldTutor = name(letterWorld)
            sleep(100)
            warp(worldTutor,"")
        until checkLock() and countTile() and not nuked
        sleep(1000)
        if bot:isInWorld(worldTutor) then 
            placeItem(9640,0,-1)
            sleep(100)
        end
    elseif bot:getInventory():findItem(9640) == 0 and (bot.gem_count >= 2000 or bot:getInventory():findItem(242) > 0) then 
        if bot:getInventory():findItem(242) == 0 then 
            while bot:getInventory():findItem(242) > 0 do 
                bot:sendPacket(2,"action|buy\nitem|world_lock")
                sleep(2000)
            end
            repeat
                nuked = false
                worldTutoer = name(letterWorld)
                sleep(100)
                warp(worldTutoer,"")
                sleep(100)
            until checkLock() and countTile() and not nuked
            sleep(1000)
            placeItem(242,0,-1)
            sleep(100)
        end
    end
end

function checkWorldTutor() 
    worldPNB = ""
  local treath = {"add_button|(%w+)|"}
  local worldgg = {}
  for i = 1,5 do 
    if not bot:isInWorld() then 
        warp(worldFarm,doorFarm)
        sleep(100)
    end
    function On_Dialog(variant, netid)
        if variant:get(0):getString() == "OnDialogRequest" then
            if variant:get(1):getString():find("myWorldsUiTab_0") then
                if variant:get(1):getString():match(treath[i]) then
                    worldgg[i] = variant:get(1):getString():match(treath[i])
                    table.insert(worldgg,variant:get(1):getString():match(treath[i]))
                    worldgg[i+1] = variant:get(1):getString():match(treath[i])
                    warp(worldgg[i],"")
                    sleep(delayWarp)
                else
                    nuked = true
                    createNewWb()
                end
            end
        end
    end
    addEvent(Event.variantlist, On_Dialog)
    bot:wrenchPlayer(getLocal().netid)
    bot:sendPacket(2, "action|dialog_return\ndialog_name|popup\nnetID|"..getLocal().netid.."|\nbuttonClicked|my_worlds")
    listenEvents(5)
    if bot:isInWorld() and not bot:isInWorld(worldFarm:upper()) and not nuked then 
        worldPNB = bot:getWorld().name
        break 
    else 
        nuked = false
        local combine = "addbutton|" .. worldgg[i] .. "|" ..worldgg[i].."|noflags|0|0|\n"..treath[1]
        table.insert(treath, combine)
    end
  end
   worldPNBTutor = worldPNB
end

function pnbTutorial()
    if worldPNBTutor ~= "" then 
        warp(worldPNBTutor,"")
        sleep(100)
    end
    myWorld = ""
    for _,tile in pairs(bot:getWorld():getTiles()) do 
        if tile.fg == 242 or tile.fg == 9640 then
            myWorld = bot:getWorld():getTile(tile.x,tile.y):getExtra().owner
        end
    end
    if bot:getWorld().name == worldPNBTutor and myWorld == getLocal().userid then 
        if bot:getInventory():findItem(itmId) >= breakTile and bot:getWorld().name == worldPNBTutor:upper() and bot:getWorld():hasAccess(bot.x-1,bot.y) > 0 then
            if not customTileBreak then
                ex = bot.x
                ye = bot.y
            else 
                ex = posX
                ye = posY
            end
            bot.auto_collect = true
            while bot:getInventory():findItem(itmId) > breakTile and bot:getInventory():findItem(itmSeed) <= 190 and bot.x == ex and bot.y == ye do
                while bot.x ~= ex and bot.y ~= ye do
                    bot:findPath(ex,ye)
                end
                for _, player in pairs(bot:getWorld():getPlayers()) do
                    if player.netid ~= getLocal().netid then
                        bot:findPath(player.posx- 1,player.posy)
                        bot:say("Sorry " .. player.name.." Im Busy Now")
                        sleep(5000)
                        bot:say("/ban " .. player.name)
                        sleep(1000)
                        bot:findPath(ex,ye)
                    end
                end
                while tilePlace(ex,ye) do 
                    for _,i in pairs(tileBreak) do 
                        if getTile(ex - 1,ye + i).fg == 0 and getTile(ex - 1,ye + i).bg == 0 then
                            place(itmId,-1,i)
                            sleep(delayPlace)
                            reconnect(worldPNBTutor,"",ex,ye)
                        end
                    end
                end
                while tilePunch(ex,ye) do 
                    for _,i in pairs(tileBreak) do 
                        if getTile(ex - 1,ye + i).fg ~= 0 or getTile(ex - 1,ye + i).bg ~= 0 then
                            punch(-1,i)
                            sleep(delayPlace)
                            reconnect(worldPNBTutor,"",ex,ye)
                        end
                    end
                end
            end
        end
    else 
        checkWorldTutor()
    end
end

function pnb(world)
    if bot:isInWorld() then
        if randomChat then
            chatBot = listChat[math.random(1,#listChat)]
            bot:say(chatBot)
            sleep(1000)
            chatBot = emoteChat[math.random(1,#emoteChat)]
            bot:say(chatBot)
            sleep(1000)
        end
        if bot:getInventory():findItem(98) > 0 then
            bot:wear(98)
            sleep(100)
        end
        if changeColorSkin then
            bot:setSkin(math.random(1,8))
            sleep(100)
        end
    end
    if tutorialPNB then
        pnbTutorial()
    elseif differentPNB then
        pnbOtherWorld()
    else
        if bot:getInventory():findItem(itmId) >= breakTile and bot:getWorld().name == world:upper() then
            if not customTileBreak then
                ex = 1
                ye = bot.y
                if ye > 40 then
                    ye = ye - 10
                elseif ye < 11 then
                    ye = ye + 10
                end
                if bot:getWorld():getTile(ex,ye).fg ~= 0 and bot:getWorld():getTile(ex,ye).fg ~= itmSeed then
                    ye = ye - 1
                end
            else
                ex = posX
                ye = posY
            end
            sleep(100)
            bot:findPath(ex,ye)
            sleep(100)
            bot.auto_collect = true
            while bot:getInventory():findItem(itmId) > breakTile and bot:getInventory():findItem(itmSeed) <= 190 and bot.x == ex and bot.y == ye do
                while tilePlace(ex,ye) do
                    for _,i in pairs(tileBreak) do
                        if bot:getWorld():getTile(ex - 1,ye + i).fg == 0 and bot:getWorld():getTile(ex - 1,ye + i).bg == 0 then
                            place(itmId,-1,i)
                            sleep(delayPlace)
                            reconnect(world,doorFarm,ex,ye)
                        end
                    end
                end
                while tilePunch(ex,ye) do
                    for _,i in pairs(tileBreak) do
                        if bot:getWorld():getTile(ex - 1,ye + i).fg ~= 0 or bot:getWorld():getTile(ex - 1,ye + i).bg ~= 0 then
                            punch(-1,i)
                            if variationDelay then
                                sleep(math.random(delayPunch - breakVariationDelay,delayPunch + breakVariationDelay))
                            else
                                sleep(delayPunch)
                            end
                            reconnect(world,doorFarm,ex,ye)
                        end
                    end
                end
            end
        end
    end
    sleep(100)
    clear()
    sleep(100)
    if buyClothes and bot.gem_count >= 4000 then 
        buyCloth()
    end
    if bot.gem_count > minimumGems then 
        while bot:getInventory().slotcount < 36 do 
            bot:sendPacket(2       ,"action|buy\nitem|upgrade_backpack")
            sleep(4000)
        end
        if bot.gem_count >= pricePack then
            while bot.gem_count >= pricePack do   
                bot:sendPacket(2,"action|buy\nitem|"..debugPack)
                sleep(2000)
            end
            storeProfit(storagePack,doorPack)
        end
    end
    warp(world,doorFarm)
end

function buyCloth()
    if #currentClothes < 4 then 
        local itemA = {} 
        for _,items in pairs(bot:getInventory():getItems()) do 
            table.insert(itemA, items.id)
            if items.isActive then 
                table.insert(currentClothes, items.id)
            end
        end
        while #currentClothes < 4 do 
            bot:sendPacket(2,"action|buy\nitem|rare_clothes")
            sleep(2000)
            for _,bCloth in pairs(bot:getInventory():getItems()) do 
                if not includesNumber(itemA, bCloth.id) and bot:getInventory():findItem(bCloth.id) >= 1 then 
                    bot:wear(bCloth.id)
                    sleep(1000)
                    table.insert(currentCloth, bCloth.id)
                end
            end
        end
    end
end

function clear()
    local function cek() 
        for _,trashs in pairs(trashList) do 
            if bot:getInventory():findItem(trashs) >= minTrash then
                return true
            end
        end
        return false
    end
    if cek() then 
        botEvent("Trashing Trash")
        for _,Trash in pairs(trashList) do 
            if bot:getInventory():findItem(Trash) > 0 then 
                bot:sendPacket(2,"action|trash\n|itemID|"..Trash)
                sleep(math.random(1000,1500))
                bot:sendPacket(2,"action|dialog_return\ndialog_name|trash_item\nitemID|"..Trash.."|\ncount|"..bot:getInventory():findItem(Trash))
                sleep(math.random(1000,1500))
            end
        end 
    end
end

function storeProfit(world,door,ids)
    bot.auto_collect = false 
    sleep(100)
    local storageWorld = ""
    local doorStorage = ""
    local itemProfit = {}
    local bgDrop = 0
    local totalDrop = 0
    if ids then 
        botEvent("Droping Profit Seed")
        storageWorld = storageSeed
        sleep(10)
        doorStorage = doorSeed 
        sleep(10)
        bgDrop = bgDropSeed 
        sleep(10)
        table.insert(itemProfit, itmSeed)
    else
        botEvent("Droping Profit Pack")
        storageWorld = storagePack
        sleep(10)
        doorStorage = doorPack
        sleep(10)
        bgDrop = bgDropPack
        sleep(10)
        for _,drop in pairs(itemPack) do 
           table.insert(itemProfit, drop)
        end
    end
    warp(storageWorld,doorStorage)
    sleep(100)
    for _,item in pairs(itemProfit) do  
        for _,tile in pairs(bot:getWorld():getTiles()) do 
            if tile.fg == bgDrop or tile.bg == bgDrop then 
                if tileDrop(tile.x,tile.y,bot:getInventory():findItem(item)) then 
                    bot:findPath(tile.x - 1,tile.y)
                    sleep(100)
                    bot:setDirection(false)
                    sleep(100)
                    if ids == itmSeed then 
                        totalDrop = 100
                        totalSeed = totalSeed + totalDrop
                    else
                        totalDrop = bot:getInventory():findItem(item)
                        totalPack = totalPack + 1
                    end
                    if bot:getInventory():findItem(item) >= totalDrop and tileDrop(tile.x,tile.y,totalDrop) then 
                        bot:sendPacket(2,"action|drop\n|itemID|"..item)
                        sleep(500)
                        bot:sendPacket(2,"action|dialog_return\ndialog_name|drop_item\nitemID|"..item.."|\ncount|"..totalDrop)
                        sleep(500)
                    end
                end
            end
            if bot:getInventory():findItem(item) < totalDrop then 
                if ids then 
                    packInfo(webhookSeed,msgIdSeed,infoPack())
                    sleep(100)
                else 
                    packInfo(webhookPack,msgIdPack,infoPack())
                sleep(100)
                end
                break
            end 
        end
    end
    joinRandom()
    sleep(100)
    warp(worldFarm,doorFarm)
    sleep(100)
    bot.auto_collect = true
end

function infoPack()
    local store = {}
    for _,obj in pairs(bot:getWorld():getObjects()) do
        if store[obj.id] then
            store[obj.id].count = store[obj.id].count + obj.count
        else
            store[obj.id] = {id = obj.id, count = obj.count}
        end
    end
    local str = ""
    for _,object in pairs(store) do
        local dropInfo = getInfo(object.id)
        str = str.."\n"..dropInfo.name.." = "..object.count
    end
    return str
end

function packInfo(wb,id,desc)
    if wb ~= "" then 
        local syn = Webhook.new(wb)
        syn.avatar_url = "https://cdn.discordapp.com/attachments/1180523579381665933/1180577805403181076/20231203_013427.png"
        syn.embed1.use = true 
        syn.embed1.color = 16740100
        syn.embed1.title = "**<:world:1229904934695338145> PROFIT INFORMATION**"
        syn.embed1.thumbnail = "https://cdn.discordapp.com/attachments/1180523579381665933/1180577805403181076/20231203_013427.png"
        syn.embed1:addField("**<:ubisyn:1235474439689207862> WORLD**","||"..bot:getWorld().name.."||\n ",false)
        syn.embed1:addField("**<:bot:1229904719720484990> LAST DROP**",bot.name.." (No."..indexBot..")\n ",false)
        syn.embed1:addField("**<:orbs:1235606674497339422> DROPPED ITEMS**",desc.. "\n  ",false)
        syn.embed1.footer.icon_url = "https://cdn.discordapp.com/attachments/1180523579381665933/1180577805403181076/20231203_013427.png"
        syn.embed1.footer.text = "Lucifer Rotation V.1.2 by SYN\n"..os.date("!%a %b %d, %Y at %I:%M p", os.time() + 7 * 60 * 60)
        if id ~= "" then 
            syn:edit(id)
        else 
            syn:send()
        end
    end
end

function waktuWorld()
    strWaktu = ""
    if censoredFarm then
        for _,worldzz in pairs(worldListBot) do
            strWaktu = strWaktu.."\n<:arrow:1231993245144318083> ||"..worldzz:upper().."|| ( <:time:1230149917499199508> "..(waktu[worldzz] or "?").." | <:peppersyn:1226198437096067274> "..(tree[worldzz] or 0).." | <:fossil:1226195061642100886> ".. (fossil[worldzz] or 0).." )"
        end
    else
        for _,worldzz in pairs(worldListBot) do
            strWaktu = strWaktu.."\n<:arrow:1231993245144318083>"..worldzz:upper().." ( <:time:1230149917499199508> "..(waktu[worldzz] or "?").." | <:peppersyn:1226198437096067274> "..(tree[worldzz] or 0).." | <:fossil:1226195061642100886> ".. (fossil[worldzz] or 0).." )"
        end
    end
    return strWaktu
end

function botEvent(status)
    local te = os.time() - t
    if webhookEvent ~= "" then 
        local syn = Webhook.new(webhookEvent)
        syn.avatar_url = "https://cdn.discordapp.com/attachments/1180523579381665933/1180577805403181076/20231203_013427.png"
        syn.embed1.use = true 
        syn.embed1.title = "BOT INFORMATION"
        syn.embed1.description = "Current World : ||".. bot:getWorld().name .."||\nTask : ".. status
        syn.embed1.color = 16740100
        syn.embed1.thumbnail = "https://cdn.discordapp.com/attachments/1180523579381665933/1180577805403181076/20231203_013427.png"
        syn.embed1:addField("<:bot:1229904719720484990> BOT INFORMATION","<:arrow:1231993245144318083> Status : "..getStatus(bot).. "("..bot:getPing()..")\n<:arrow:1231993245144318083> Name : "..bot.name.." (No."..indexBot..")\n<:arrow:1231993245144318083> Level :" ..bot.level.."\n",true)
        syn.embed1:addField("","",false)
        syn.embed1:addField("PROFIT BOT","<:arrow:1231993245144318083> Total Pack = " ..totalPack.. "\n<:arrow:1231993245144318083> Total Seed = "..totalSeed.. "\n<:arrow:1231993245144318083> Obtained Gems = "..numF(bot.obtained_gem_count),true)
        syn.embed1:addField("","",false)
        syn.embed1:addField(getInfo(itmId).name:upper().." FARM","<:arrow:1231993245144318083> Tree Planted :" ..numF(planted).."\n<:arrow:1231993245144318083> Ready Harvest : "..numF(ready).."\n",true)
        syn.embed1:addField("<:world:1229904934695338145>  TOTAL WORLD ("..totalFarm..")",waktuWorld().."\n",false)
        syn.embed1:addField("UPTIME","<:arrow:1231993245144318083>"..math.floor(te/86400).." Days "..math.floor(te%86400/3600).." Hours "..math.floor(te%86400%3600/60).." Minutes",false)
        syn.embed1.footer.icon_url = "https://cdn.discordapp.com/attachments/1180523579381665933/1180577805403181076/20231203_013427.png"
        syn.embed1.footer.text = "Lucifer Rotation V.1.2 \n"..os.date("!%a b %d, %Y at %I:%M p", os.time() + 7 * 60 * 60)
        if msgIdEvent ~= "" then 
            syn:edit(msgIdEvent)
        else 
            syn:send()
        end
    end
end

function notifBot(webhookInfo,status)
    if webhookInfo ~= "" then 
        local syn = Webhook.new(webhookInfo)
        syn.avatar_url = "https://cdn.discordapp.com/attachments/1180523579381665933/1180577805403181076/20231203_013427.png"
        syn.embed1.use = true 
        syn.embed1.title = status
        syn.embed1.color = 2500399
        syn:send()
    end
end

function scanReady() 
    local count = 0 
    local planteds = 0
    local fossils = 0
    for _,tile in pairs(bot:getWorld():getTiles()) do 
        if tile.fg == itmSeed or tile.bg == itmSeed then 
            planteds = planteds + 1 
        end
        if tile:canHarvest() and bot:getWorld():hasAccess(tile.x,tile.y) > 0 then 
            count = count + 1
            if tile:hasFlag(4096) then 
                if worldFireHose ~= "" then 
                    clearFire(worldFarm,doorFarm)
                    sleep(100)
                else 
                    nuked = true 
                end
            end
        end
        if tile.fg == 788 then 
            --toxic
        end
        if tile.fg == 3918 then 
            fossils = fossils + 1
        end
    end
    planted = planteds 
    ready = count 
    fossil[worldFarm] = fossils
    return count
end 

function joinRandom()
    if joinRandomWorld then 
        for _,worldas in pairs(listToJoin) do 
            warp(worldas,"")
            sleep(100)
        end
    end
end


while true do 
    planted = 0 
    ready = 0 
    while bot.status ~= BotStatus.online do 
        sleep(1000)
    end
    if takePickaxe and bot:getInventory():findItem(98) == 0 then
        takeItem(worldPick,doorPick,98,1)
        sleep(100)
    end
    if changeSkin and bot:isInWorld() then 
        bot:setSkin(math.random(1,8))
    end
    sleep(delayExe *( indexBot - 1))
    dataWorld = takefile(listFarm)[1]
    sleep(100)
    if dataWorld then 
        worldFarm = dataWorld.world
        doorFarm = dataWorld.door
    end
    if #worldListBot >= 10 then 
        worldListBot = {} 
        tree = {}
        waktu = {} 
        fossil = {}
    end
    table.insert(worldListBot,worldFarm:upper())
    warp(worldFarm,doorFarm)
    sleep(100)
    if not nuked then 
        tt = os.time()
        while scanReady() > 0 do  
            harvest(worldFarm)
            sleep(100)
        end
        totalFarm = totalFarm + 1
        if totalFarm == terminateBotAfterFarm then 
            bot.auto_reconnect = false 
            bot:disconnect()
            bot:stopScript()
        end
        waktu[worldFarm] = math.floor(tt%86400/3600).." H "..math.floor(tt%3600/60).." M "..math.floor(tt%60).." S"
        botEvent("Finishing Farm")
    else 
        notifBot(webhookNuked,"<a:ping:1233214776880922757> ||".. worldFarm:upper().. "|| NUKED @everyone !  ")
        print(worldFarm:upper().."NUKED")
        waktu[worldFarm] = "NUKED"
        tree[worldFarm] = "NUKED"
        fossil[worldFarm] = 0
        nuked = false
    end
end
